## Описание языка XML

> [!info]
> **XML (eXtensible Markup Language - расширяемый язык разметки)** — это язык программирования, который состоит из объявлений в виде информации и определяющих тегов. С его помощью удобно хранить и передавать любые данные.

### Теги

B XML каждый элемент должен быть заключен в теги.
**Тег** — это некий текст, обернутый в угловые скобки:
`<tag>`

Текст внутри угловых скобок — **название тега**.

Тега всегда два:

- Открывающий — текст внутри угловых скобок `<tag>`
- Закрывающий — тот же текст, но добавляется символ «/» `</tag>`

> [!tip]
> Язык не зависит от ОС и среды обработки. XML служит для представления неких данных **в виде структуры**, которую вы не можете сами разработать или подстроить под программу или сервис.


Именно поэтому данный зык называют расширяемым, и в этом его главное достоинство, за которое его так ценят. 

| Плюсы языка XML | Минусы XML |
| - | - |
| легкость чтения, подача в простой форме| чрезмерный синтаксис, большое количество сущностей и тегов |
| стандартный вид кодировки (Спецификация обязывает парсеры понимать две кодировки: UTF-8 и UTF-16); | не содержит язык поддержки для типов данных; |
| возможность создания разных структур (списков, схем, деревьев); | сложное использование пространств имен. |
| возможность восстановить данные, которые были сохранены в XML; | |
| возможность обмена данными между любыми платформами; | |
| популярность в разных сферах программирования | |

#### Альтернативные варианты языка XML: **XAML, JSON**

XML-формат представляет собой платформа-независимый способ структурирования информации путём представления документа в виде дерева элементов каждый из которых может иметь набор атрибутов, представляющих пару “имя/значение”, и содержать другие элементы и/или текст. При этом каждый элемент дерева может ссылаться на другие элементы с помощью своих атрибутов

#### XML атрибуты должны **заключатся в кавычки**

Каждый файл разметки содержит один корневой элемент.

- В файле определяются все графические элементы и их атрибуты, которые составляют интерфейс.

При создании разметки в XML следует соблюдать некоторые правила: каждый файл разметки должен содержать один корневой элемент, который должен

объект `View` или `ViewGroup`.

В данном случае корневым элементом является элемент `ConstraintLayout`, который содержит элемент `TextView`.

- Как правило, корневой элемент содержит определение используемых пространств имен XML.

Например, в коде по умолчанию в `ConstraintLayout` мы можем увидеть такие атрибуты:

```jsx
xmlns:android="[http://schemas.android.com/apk/res/android](http://schemas.android.com/apk/res/android)" 
xmlns:app="[http://schemas.android.com/apk/res-auto](http://schemas.android.com/apk/res-auto)" 
xmlns:tools="[http://schemas.android.com/tools](http://schemas.android.com/tools)"
```

> [!tip]
> Каждое пространство имен задается следующим образом: `xmlns:префикс=”название ресурса”`.

#### Пример
```jsx
xmlns:android=http://schemas.android.com/apk/res/android
```

> [!info]
> **Название ресурса** (или URI — Uniform Resource Indicator) —`http://schemas.android.com/apk/res/android`

И этот ресурс сопоставляется с префиксом android `xmlns:android`. То есть через префикс мы сможем ссылаться на **функциональность** этого пространства имен.

> Каждое пространство имен определяет некоторую функциональность, которая используется в приложении, например, предоставляют теги и атрибуты, которые необходимые для построения приложения.

`xmlns:android="[http://schemas.android.com/apk/res/android](http://schemas.android.com/apk/res/android)":` содержит основные атрибуты, которые предоставляются платформой Android, применяются в элементах управления н определяют их визуальные свойства (например, размер, позиционирование). Например, в коде Constraint используется следующий атрибут из пространства имен:

#### [http://schemas.android.com/apk/res/android](http://schemas.android.com/apk/res/android):

`android:layout_width="match_parent"`

#### xmlns:app="[http://schemas.android.com/apk/res-auto](http://schemas.android.com/apk/res-auto)":

Содержит атрибуты, которые определены в рамках приложения.

Например, в коде TextView: `app:layout_constraintBottom_toBottomOf="parent"`

#### xmlns:tools="[http://schemas.android.com/tools](http://schemas.android.com/tools)":

Применяется для работы в режиме дизайнера в **Android Studio**

> [!tip]
> При разработке приложений под Android мы можем использовать различные типы измерений

#### рх: пиксели текущего экрана.

**Однако эта единица измерения не рекомендуется**, так как реальное представление внешнего вида может изменяться в зависимости от устройства; каждое устройство имеет определенный набор пикселей на дюйм, поэтому количество пикселей на экране может также меняться

#### dp: (device-independent pixels)

Независимые от плотности экрана пиксели. Абстрактная единица измерения, основанная на физической плотности экрана с разрешением 160 dpi (точек на дюйм). В этом случае 1dp = 1px. Если размер экрана больше или меньше, чем 160dpi, количество пикселей которые применяются для отрисовки 1dp соответственно увеличивается или уменьшается. Например, на экране с 240 dpi 1dp=1,5px, а на экране с 320dpi, 1dp=2px. Общая формула для получения количества физических пикселей из бp: px = dp * (dpi / 160)

#### sp: (scale-independent pixels)

Независимые от масштабирования пиксели. Допускают настройку размеров, производимую пользователем. Рекомендуются для работы со шрифтами 

#### pt: 1/72 дюйма, базируются на физических размерах экрана

#### mm: миллиметры

#### in: дюймы

Для упрощения работы с размерами все размеры **разбиты на несколько групп**:

- **Idpi (low):** ~120dpi
- **mdpi (medium):** ~160dpi
- **hdpi (high):** ~240dpi (к данной группе можно отнести такое устройство как Nexus One)
- **xxxhdpi (extra-extra-extra-high):** ~640dpi (Nexus 6/6P, Samsung Galaxy S6)
- **xhdpi (extra-high):** ~320dpi (Nexus 4)
- **xxhdpi (extra-extra-high):** ~480dpi (Nexus 5/5X, Samsung Galaxy S5)

### Что такое Layout?

> [!info]
> **Android Layout** — это класс, управляющий тем, как его подкомпоненты появляются на экране. Любой компонент является `View` (или дочерним от `View`) может быть дочерним `Layout`.

Все классы `Layout` расширены из класса `ViewGroup` (дочерний `View`), поэтому вы тоже можете создать кастомизированный `Layout`, создав расширенный класс из `ViewGroup`.

### Типы Layout

| LinearLayout (Horizontal) (Vertical) | ViewGroup который располагает дочерние компоненты по единственному направлению, вертикально или горизонтально. Вы можете определить направление, используя android:orientation |
| --- | --- |
| RelativeLayout | ViewGroup который изображает View в связанной позиции. Позиция каждого View может быть определена как связанный с другим дочерним View (например слева или внизу другого View) или в позициях, связанных с родителем RelativeLayout (например, расставить внизу, слева или в центре) |
| TableLayout | ViewGroup который отображает дочерние компоненты в строках и столбцах |
| GridLayout | Использует сетку бесконечно тонких линий для отделения области рисования на: строки, столбцы и ячейки (cell). Он также помогает расположить (span) строки и столбцы, то есть позволяет объединить смежные ячейки в большую ячейку (прямоугольник), чтобы содержать View. |
| FrameLayout | Это заполнитель на экране, который вы можете использовать для отображения индивидуального View. |

### ConstraintLayout

Android Studio по умолчанию предлагает нам использовать ConstraintLayout при создании разметки экрана. Он предлагает контейнер, который позволяет создавать гибкие и масштабируемые визуальные интерфейсы. 

> [!tip]
> Для позиционирования элемента внутри необходимо указать ограничения (constraints). Каждое ограничение устанавливает позиционирование элемента **либо по горизонтали, либо по вертикали**.